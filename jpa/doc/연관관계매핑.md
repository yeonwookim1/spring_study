연관관계 매핑

- 객체의 참조와 테이블의 외래키를 매핑
- 방향, 다중성, 연관관계의 주인을 이해
- 객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것



객체를 테이블에 맞게 데이터중심으로 설계시

- 외래키를 직접 셋팅, 직접 검색 -> 객체지향스럽지 않음
- 테이블은 조인을 사용하여 테이블을 탐색
- 객체는 참조를 통하여 객체를 탐색

```java
//삽입
Team team = new Team();
team.setName("TeamA");
em.persist(team);

User user = new User();
user.setUserName("user1");
user.setTeamId(team.getId());
em.persist(user);

//검색
User findUser = em.find(User.class, user.getId());
Long findTeamId = findUser.getTeamId();
Team findTeam = em.find(Team.class, findTeamId);
```



1. 단방향 매핑
   - @ManyToOne 어노테이션을 사용하여 다대일 관계를 선언
   - '다'인 클래스에 '일'인 객체를 선언한다.
   - 외래키 관계를 맺는다.
   - 반대쪽에서는 객체가 검색이 안됨(Team에서 User를 조회할 순 없음)

```java
public class User {
  ...
  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "team_id")
  private Team team;
  ...
}

public static void main(String[] args){
  ...
  Team team = new Team();
  team.setName("TeamA");
  em.persist(team);

  User user = new User();
  user.setUserName("user1");
  user.setTeam(team);			//TEAM 객체를 넣어주면 JPA가 join 관계를 매핑
  em.persist(user);
  ...
}
```



2. 양방향 매핑

   - 객체 양쪽에 선언을 해줘야 양방향으로 가능
   - 테이블은 외래키를 이용하여 양방향 가능(테이블 방향 자체가 없음)

   ```java
   public class Team {
     ...
     @OneToMany(mappedBy = "team")		//어디랑 연관되어있는지 mappedBy를 써줘야함
     private List<User> list = new ArrayList<>();
     ...
   }
   ```



3. 연관관계 주인과 mappedBy
   - 객체와 테이블이 관계를 맺는 차이
   - 객체 연관관계 = 2개
     - 회원 -> 팀 1개(단방향)
     - 팀 -> 회원 1개(단방향)
   - 테이블 연관관계 = 1개
     - 회원 <-> 팀 1개(양방향)
   - 객체의 양방향은 단방향 연관관계 2개인 것
   - 테이블은 외래키 하나로 두 테이블의 연관관계가 관리(양쪽 조인)



4. 연관관계의 주인
   - 양방향 매핑 규칙
     - 객체의 두 관계중 하나를 연관관계의 주인으로 지정
     - 연관관계의 주인만이 외래키를 관리(write, update)
     - 주인이 아닌 쪽은 read만
     - 주인은 mappedBy 속성 사용 x
     - 주인이 아니면 mappedBy로 속성으로 주인 지정
   - 외래키가 있는 곳을 주인으로 (1:다인 경우 다인쪽에 연관관계 주인) -> 성능이슈, 예상하지 못 한 쿼리 방지















