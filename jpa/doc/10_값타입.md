1. 엔티티 타입
   - @Entity로 정의하는 객체
   - 데이터가 변해도 식별자로 지속해서 추적 가능



2. 값 타입

   - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
   - 식별자가 없고 값만 있으므로 추적 불가능

   ​

   ​

   - 기본값 타입 : 자바기본타입(int, double), 래퍼 클래스(Integer, Long), String
     - 생명주기를 엔티티에 의존
     - 공유하면 안됨

   ​

   ​

   - 임베디드 타입 : 정의해서 사용 (복합 값)

     - 새로운 값 타입을 직접 정의
     - JPA는 임베디드 타입이라함
     - 기본값 타입을 모아 만듬(엔티티의 값일뿐)
     - int, String과 같은 기본값 타입

   - 특징

     - 재사용, 응집력이 높음
     - 해당 값만 사용하는 매소드 생성 가능
     - 소유한 엔티티의 생명주기에 의존
     - 사용하나 안사용하나 매핑하는 테이블은 같음
     - 객체와 테이블을 세밀하게 매핑 가능
     - 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.

   - 연관관계

     - 값을 가질수도 있으며, 엔티티를 소유할 수도 있음

     - 임베디드 타입을 중복해서 사용하려면 AttributeOverrides를 사용

     - ```java
       @Embedded
       private Address homeAddress;

       @Embedded
       @AttributeOverrides({
         @AttributeOverride(name = "city", column = @Column(name = "work_city")),
         @AttributeOverride(name = "street", column = @Column(name = "work_street")),
         @AttributeOverride(name = "zipCode", column = @Column(name = "work_zipCode"))
       })
       private Address workAddress;
       ```

       ​

   ​

   - 컬렉션 값 타입 :  collection value type





3. 값 타입과 불변 객체

   - embedded 타입을 set하면 값이 변경 된다. (참조하고 있기에)

   - embedded 타입은 공유하면 위험할 수 있음

   - ```java
     Address address = new Address("seoul", "sangamdong", "52");

     User user4 = new User();
     user4.setUserName("user4");
     user4.setHomeAddress(address);
     em.persist(user4);

     User user5 = new User();
     user5.setUserName("user4");
     user5.setHomeAddress(address);
     em.persist(user5);

     //아래와 같이 값을 변경시 user4, user5 다 바뀌게 된다.
     user4.getHomeAddress().setCity("usa");

     //공유되는 embedded 타입 수정시 새로운 객체로 할당하여 변경
     Address newAddress = new Address(address.getCity(), address.getStreet(), address.getZipCode());
     user4.setHomeAddress(newAddress);
     ```

   - 값을 복사해서 사용하면 공유 참조로 인해 발생하는 오류를 막을 수 있다.

   - 문제는 직접 정의한 값 타입은 자바의 기본타입(primitive)가 아니라 객체 타입

   - 객체의 공유 참조는 막을 수 없다.

   - 객체 타입을 수정할 수 없게 만들면서 오류를 차단

   - 값타입은 불변객체로 선언해야 함, 생성자로만 생성(또는 private)

   - 깔끔하게 불변객체로 선언하는 하여 오류를 방어하는 것을 추천





4. 값 타입의 비교
   - 동일성비교(identity ) : 인스턴스의 참조 값을 비교, == 사용	
   - 동등성비교(equivalence) 비교 : 인스턴스 값을 비교 equals() 사용
   - 값타입은 equals()를 사용, equals()를 재정의 하여 사용





5. 값 타입 컬렉션
   - ​